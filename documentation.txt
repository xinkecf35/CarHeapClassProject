For the the CarTracker Program/Project 3, the project brief outlined specifically that we must create a minimum heap that is indexable. The reasoning was that we must make retrieval and update operations in logarithmic time. Now for the just retrieval of the minimum of the heap, this is can be done in O(1) time complexity as we would just need to return the first element of the array that is backing of the heap. However, in order to update an arbitrary Car object anywhere in the heap, we would like to avoid the O(n) worst case time complexity needed to do traversal of the entire heap/the array backing the heap to find the object and then the O(log n) time needed to check the heap invariant of updated object.

To reduce the the time complexity of the find the object in heap, we now use the indexable part of the heap, that is the indirection table for the heap data structure. The implementation for the indirection table chosen was the HashMap from the Java Standard Library. A HashMap implementation implemented with the Car's VIN as keys and the values that it is to those keys is the index of the Car object in the heap. Provided that the hash function for the keys in HashMap is uniformly distributed, this method would provide O(1) amortized access to the Car object. Once we update the Car object, we again need O(log n) time complexity to check the heap invariant for the update/removal operations.

Regarding the O(1) amortized time complexity to access objects, there are few caveats. If the hashing function is not uniformly distribute we may expect to see many collisions in the HashMap. However, the worst case time complexity to find a value given a key is different depending on the Java version. Prior to Java 8, HashMap used Linked List for closed addressing. This would mean a worst case O(n) lookup time. However beginning with Java 8, HashMap now uses a balanced search tree to resolve hashing collisions. As outlined in JEP 180 (http://openjdk.java.net/jeps/180) the worst case is now O(log n). Of course, to reduce the likelihood of the worst case, a good hashing function is also needed. Now the standard library uses a hashing implementation as outlined in Josh Blosh's "Effective Java". Coupled with a good load factor, we can reasonably expect O(1) time complexity to access Car objects.

Finally, as for keeping track the minimum Car objects for make and model, it was decided to sacrifice some space and to store separate heaps for each make and model and store these heaps as values in a HashMap with the keys for each of the heaps stored as a concatenated of the make and model. This implementation means a O(1) access to the heaps and operations on these heaps are the same as mentioned above. Of course, dedicated overall heaps for both mileage and price are maintained for simplicity.